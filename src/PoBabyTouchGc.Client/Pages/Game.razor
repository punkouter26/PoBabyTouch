@page "/game"
@using System.Net.Http.Json
@using System.Timers
@using PoBabyTouchGc.Shared.Models
@using PoBabyTouchGc.Client.Services
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@inject HttpClient Http
@inject GameStateService GameStateService
@inject IGamePhysicsEngine PhysicsEngine
@inject CircleManager CircleManager
@inject GameStatsService GameStatsService
@inject ILogger<Game> Logger
@implements IDisposable

<PageTitle>PoBabyTouchGc</PageTitle>

<div class="game-container @(GameStateService.IsGameOver ? "game-over" : "")">
    @if (!isBabyMode)
    {
        <div class="game-header">
            <div class="score-display">Score: @GameStateService.CurrentScore</div>
            <div class="timer-display">Time: @timeRemaining</div>
        </div>
    }
    else
    {
        <div class="game-header">
            <div class="baby-mode-indicator">Baby Mode</div>
            <div class="score-display">Score: @GameStateService.CurrentScore</div>
        </div>
    }
    
    <div class="game-area" @ref="gameAreaRef" @onclick="HandleBackgroundClick" @key="gameAreaKey">
        <canvas @ref="canvasRef" width="1" height="1" style="position:absolute; top:0; left:0; pointer-events:none;"></canvas>
        @foreach (var circle in circles)
        {
            <div class="game-circle @circle.PersonClass @(circle.IsVisible ? "appear" : "disappear") @(circle.IsHit ? "hit-effect" : "")"
                 style="left: @(circle.X)px; top: @(circle.Y)px; 
                        width: @(circle.Radius * 2)px; height: @(circle.Radius * 2)px;"
                 @onclick="@(e => HandleCircleClick(e, circle))"
                 @onclick:stopPropagation="true"
                 @key="circle.Id">
            </div>
        }
    </div>
      @* Removed the start overlay since we want the game to start automatically *@
    
    @if (GameStateService.IsGameOver)
    {
        <div class="game-over-overlay">
            <h2>Game Over!</h2>
            <p>Your final score: @GameStateService.CurrentScore</p>
            <button class="restart-button" @onclick="RestartGame">Play Again</button>
            <button class="home-button" @onclick="GoToHome">Main Menu</button>
        </div>
    }

    @if (showHighScoreModal)
    {
        <div class="high-score-modal">
            <div class="high-score-content @(showSuccessAnimation ? "success-animation" : "")">
                @if (!showSuccessAnimation)
                {
                    <h2>ðŸŽ‰ NEW HIGH SCORE! ðŸŽ‰</h2>
                    <p>Your score: <span class="score-value">@GameStateService.CurrentScore</span></p>
                    <p>Enter your initials (3 letters):</p>
                    <input type="text" 
                           maxlength="3" 
                           @bind="playerInitials" 
                           @oninput="HandleInitialsInput" 
                           placeholder="ABC"
                           class="simple-initials-input"
                           autofocus />
                    <div class="button-group">
                        <button class="skip-button" @onclick="CancelHighScore">SKIP</button>
                    </div>
                }
                else
                {
                    <div class="success-content">
                        <div class="success-icon">ðŸŽ‰</div>
                        <h2>Score Submitted!</h2>
                        <p>Congratulations @playerInitials!</p>
                        <p>Your score of @GameStateService.CurrentScore has been saved.</p>
                        <div class="spinner"></div>
                        <p class="redirecting">Redirecting to leaderboard...</p>
                    </div>
                }
            </div>
        </div>
    }
</div>


@code {
    private ElementReference gameAreaRef;
    private ElementReference canvasRef;
    private Timer? gameTimer;
    private Timer? physicsFpsTimer;
    private Random random = new Random();
    private int timeRemaining = 3; // Short timer for testing
    private List<GameCircle> circles = new List<GameCircle>();
    private int gameAreaWidth = 0;
    private int gameAreaHeight = 0;
    private bool showHighScoreModal = false;
    private bool showSuccessAnimation = false;
    private string playerInitials = "";
    private Guid gameAreaKey = Guid.NewGuid(); // New field for forcing re-render
    private bool isBabyMode = false; // Baby mode flag
    
    // Constants
    private const int TotalCircles = 7;
    private const int CircleRadiusPercent = 5; // % of screen width
    private const int CircleReappearDelayMs = 800;
    private const int PhysicsFps = 60;
    private const float BaseSpeed = 2.0f;
    private const float SpeedIncreaseFactor = 1.0f; // Changed from 1.5f to 1.0f
    private const float MaxSpeed = 3.0f; // Maximum velocity cap for baby mode

    protected override void OnInitialized()
    {
        GameStateService.OnChange += StateHasChanged;
        
        // Check for baby mode query parameter
        var uri = new Uri(NavigationManager.Uri);
        isBabyMode = uri.Query.Contains("mode=baby", StringComparison.OrdinalIgnoreCase);
    }
    
    protected override void OnParametersSet()
    {
        // Check if baby mode parameter changed
        var uri = new Uri(NavigationManager.Uri);
        bool newBabyMode = uri.Query.Contains("mode=baby", StringComparison.OrdinalIgnoreCase);
        
        if (newBabyMode != isBabyMode)
        {
            isBabyMode = newBabyMode;
            
            // Restart game with new mode if game area is initialized
            if (gameAreaWidth > 0 && gameAreaHeight > 0)
            {
                RestartGame();
            }
        }
    }
      protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // Initialize game area dimensions
                var dimensions = await JSRuntime.InvokeAsync<int[]>("getElementDimensions", gameAreaRef);
                if (dimensions != null && dimensions.Length >= 2)
                {
                    gameAreaWidth = dimensions[0];
                    gameAreaHeight = dimensions[1];                    // Initialize circle positions
                    InitializeCircles();

                    // Set up physics timer
                    physicsFpsTimer = new Timer(1000.0 / PhysicsFps);
                    physicsFpsTimer.Elapsed += UpdatePhysics;
                    physicsFpsTimer.AutoReset = true;
                    
                    // Automatically start the game without showing the start overlay
                    StartGame();
                }
                else
                {
                    // Handle the case where dimensions are not as expected
                    Console.Error.WriteLine("Error: Could not get valid game area dimensions.");
                    // Potentially display a message to the user or attempt retry
                }
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"Error during JS interop 'getElementDimensions': {ex.Message}");
                // Potentially display an error message to the user
                // or implement a fallback mechanism if game can't start.
            }
        }
    }
    
    private void InitializeCircles()
    {
        // Calculate circle radius based on screen width
        int circleRadius = (int)(gameAreaWidth * CircleRadiusPercent / 100);

        // Define person types for circles (Matt, Nick, Kim)
        string[] personTypes = new[] { "matt", "nick", "kim" };

        // Use CircleManager to initialize circles (Strategy Pattern for physics)
        circles = CircleManager.InitializeCircles(
            TotalCircles, 
            gameAreaWidth, 
            gameAreaHeight,
            circleRadius,
            personTypes);
            
        Logger.LogInformation("Initialized {Count} circles using CircleManager", circles.Count);
    }
    
    // IsCircleOverlapping is now handled by IGamePhysicsEngine
    // Removed duplicate code - using PhysicsEngine.IsOverlapping() instead
    
    private void StartGame()
    {
        if (gameAreaWidth == 0 || gameAreaHeight == 0)
            return;
            
        // Stop and dispose existing timers to ensure a clean restart
        gameTimer?.Stop();
        gameTimer?.Dispose();
        physicsFpsTimer?.Stop();
        physicsFpsTimer?.Dispose();

        GameStateService.StartGame();
        timeRemaining = 3; // Short timer for testing
        
        InitializeCircles();
        
        physicsFpsTimer = new Timer(1000.0 / PhysicsFps);
        physicsFpsTimer.Elapsed += UpdatePhysics;
        physicsFpsTimer.AutoReset = true;
        physicsFpsTimer.Start();
        
        // Only start game timer if not in baby mode
        if (!isBabyMode)
        {
            gameTimer = new Timer(1000);
            gameTimer.Elapsed += GameTimerTick;
            gameTimer.AutoReset = true;
            gameTimer.Start();
        }

        gameAreaKey = Guid.NewGuid(); // Force re-render of game area
    }
    
    private void GameTimerTick(object? sender, ElapsedEventArgs e)
    {
        InvokeAsync(() =>
        {
            timeRemaining--;
            
            if (timeRemaining <= 0)
            {
                EndGame();
            }
            
            StateHasChanged();
        });
    }
    
    private async void EndGame()
    {
        gameTimer?.Stop();
        physicsFpsTimer?.Stop();
        
        GameStateService.EndGame();
        
        // For testing purposes, always show the modal
        showHighScoreModal = true;
        
        // Check if this score qualifies as a high score (for future use)
        try
        {
            var response = await Http.GetAsync($"api/highscores/check/{GameStateService.CurrentScore}");
            if (response.IsSuccessStatusCode)
            {
                var apiResponse = await response.Content.ReadFromJsonAsync<ApiResponse<bool>>();
                if (apiResponse?.Success == true)
                {
                    var isHighScore = apiResponse.Data;
                    Console.WriteLine($"Score {GameStateService.CurrentScore} is high score: {isHighScore}");
                }
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error checking if score is high score: {ex.Message}");
        }
    }
      private void RestartGame()
    {
        showHighScoreModal = false;
        showSuccessAnimation = false;
        playerInitials = "";
        StartGame(); // Call StartGame instead of GameStateService.StartGame() to properly reinitialize everything
    }
    
    private void GoToHome()
    {
        NavigationManager.NavigateTo("/");
    }
    
    private void UpdatePhysics(object? sender, ElapsedEventArgs e)
    {
        if (!GameStateService.IsGameActive || GameStateService.IsGameOver)
            return;
            
        InvokeAsync(() =>
        {
            // Calculate current speed multiplier based on remaining time
            // The speed increases as time decreases (disabled in baby mode)
            float speedMultiplier = isBabyMode ? 1.0f : 1.0f + (3 - timeRemaining) / 3.0f * (SpeedIncreaseFactor - 1.0f);
            
            // Delegate to physics engine (Strategy Pattern - StandardPhysicsEngine or BabyModePhysicsEngine)
            PhysicsEngine.UpdateCirclePhysics(circles, gameAreaWidth, gameAreaHeight, speedMultiplier);
            
            StateHasChanged();
        });
    }
    
    private async Task HandleCircleClick(MouseEventArgs e, GameCircle circle)
    {
        if (!GameStateService.IsGameActive || GameStateService.IsGameOver || !circle.IsVisible)
            return;
            
        // Add a temporary class for visual feedback (e.g., a quick scale/flash)
        circle.IsHit = true;
        
        // Increment score (only in normal mode)
        if (!isBabyMode)
        {
            GameStateService.AddScore(1);
        }
        
        // Hide the circle
        circle.IsVisible = false;

        // Ensure immediate UI update for score and circle visibility
        StateHasChanged();
        
        // This try/catch prevents the JSInterop error from crashing the app
        try {
            // Play sound effect based on person
            await JSRuntime.InvokeVoidAsync("playSound", circle.Person);
        }
        catch {
            // Silent fail for sound errors
        }
        
        // Schedule circle to reappear after delay
        _ = Task.Run(async () =>
        {
            await Task.Delay(CircleReappearDelayMs);
            
            await InvokeAsync(() =>
            {
                if (GameStateService.IsGameActive && !GameStateService.IsGameOver)
                {
                    // Remove hit class
                    circle.IsHit = false;

                    // Find a new non-overlapping position
                    bool validPosition = false;
                    int attempts = 0;
                    int maxAttempts = 50;
                    
                    // Ensure game area is large enough for the circle to reappear
                    if (gameAreaWidth < 2 * circle.Radius || gameAreaHeight < 2 * circle.Radius)
                    {
                        Console.Error.WriteLine($"Game area too small for circle {circle.Id} to reappear. Width: {gameAreaWidth}, Height: {gameAreaHeight}, Radius: {circle.Radius}");
                        // Circle will not reappear if area is too small.
                        return;
                    }

                    while (!validPosition && attempts < maxAttempts)
                    {
                        attempts++;
                        
                        circle.X = random.Next(circle.Radius, gameAreaWidth - circle.Radius);
                        circle.Y = random.Next(circle.Radius, gameAreaHeight - circle.Radius);
                        
                        // Check for overlaps using PhysicsEngine
                        validPosition = !circles.Any(c => c.IsVisible && c.Id != circle.Id && PhysicsEngine.IsOverlapping(circle, c));
                    }

                    if (validPosition)
                    {
                        // Change velocity to make movement varied
                        circle.VelocityX = (float)(random.NextDouble() * 2 - 1) * BaseSpeed;
                        circle.VelocityY = (float)(random.NextDouble() * 2 - 1) * BaseSpeed;

                        // Make circle visible again
                        circle.IsVisible = true;
                        StateHasChanged();
                    }
                    else
                    {
                        Console.Error.WriteLine($"Could not find a non-overlapping position for circle {circle.Id} after {maxAttempts} attempts. It will not reappear.");
                        // Optionally, handle this case differently, e.g., try reducing radius temporarily or queue it for later.
                    }
                }
            });
        });
    }
    
    private void HandleBackgroundClick()
    {
        if (!GameStateService.IsGameActive && !GameStateService.IsGameOver)
            StartGame();
    }
    
    private async Task HandleInitialsInput(ChangeEventArgs e)
    {
        var input = e.Value?.ToString() ?? "";
        
        // Filter to only letters and convert to uppercase
        playerInitials = new string(input.ToUpper().Where(char.IsLetter).ToArray());
        
        // Truncate to 3 characters if longer
        if (playerInitials.Length > 3)
            playerInitials = playerInitials.Substring(0, 3);
        
        StateHasChanged();

        // Auto-submit when 3 characters are entered
        if (playerInitials.Length == 3)
        {
            await Task.Delay(500); // Small delay for visual feedback
            await SubmitHighScore();
        }
    }
    
    private async Task SubmitHighScore()
    {
        if (playerInitials.Length != 3)
            return;
            
        try
        {
            // Show success animation
            showSuccessAnimation = true;
            StateHasChanged();
            
            // Create score submission object
            var scoreSubmission = new SaveHighScoreRequest
            {
                PlayerInitials = playerInitials,
                Score = GameStateService.CurrentScore
            };
            
            Console.WriteLine($"Attempting to submit high score: {GameStateService.CurrentScore} for {playerInitials}");
            
            // Submit score to leaderboard API
            var response = await Http.PostAsJsonAsync("api/highscores", scoreSubmission);
            
            if (response.IsSuccessStatusCode)
            {
                Console.WriteLine($"Successfully submitted high score: {GameStateService.CurrentScore} for {playerInitials}");
                
                // Record game statistics
                await RecordGameStatistics(playerInitials);
                
                // Wait a moment to show the success animation
                await Task.Delay(2000);
                
                showHighScoreModal = false;
                NavigationManager.NavigateTo("/leader");
            }
            else
            {
                Console.Error.WriteLine($"Error submitting high score: {response.StatusCode}");
                // For testing, still show success even if API fails
                Console.WriteLine($"Testing mode: Simulating successful submission for {playerInitials} with score {GameStateService.CurrentScore}");
                
                // Wait a moment to show the success animation
                await Task.Delay(2000);
                
                showHighScoreModal = false;
                NavigationManager.NavigateTo("/");
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error submitting high score: {ex.Message}");
            // For testing, still show success even if API fails
            Console.WriteLine($"Testing mode: Simulating successful submission for {playerInitials} with score {GameStateService.CurrentScore}");
            
            // Wait a moment to show the success animation
            await Task.Delay(2000);
            
            showHighScoreModal = false;
            NavigationManager.NavigateTo("/");
        }
    }
    
    private void CancelHighScore()
    {
        showHighScoreModal = false;
        GameStateService.EndGame(); // This will set IsGameOver to true
    }
    
    private async Task RecordGameStatistics(string initials)
    {
        try
        {
            // Calculate circles tapped (score in baby mode, or score in normal mode)
            int circlesTapped = GameStateService.CurrentScore;
            
            // Record game session statistics using GameStatsService
            await GameStatsService.RecordGameSessionAsync(
                initials,
                GameStateService.CurrentScore,
                circlesTapped,
                60 // Assuming 60 seconds playtime - could track actual time
            );
            
            Logger.LogInformation("Recorded game statistics for {Initials}: Score={Score}", 
                initials, GameStateService.CurrentScore);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to record game statistics");
            // Don't throw - we don't want to break the game flow if stats fail
        }
    }
    
    public void Dispose()
    {
        gameTimer?.Dispose();
        physicsFpsTimer?.Dispose();
        GameStateService.OnChange -= StateHasChanged;
    }
    
    // GameCircle class is now defined in IGamePhysicsEngine.cs (part of physics engine abstraction)
    // This promotes reusability and testability
}

